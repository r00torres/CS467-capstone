<script src="/static/three.js"></script>

<script src="/static/OrbitControls.js"></script>
<script src="/static/OBJLoader.js"></script>
<script src="/static/GLTFLoader.js"></script>
<script src="/static/MTLLoader.js"></script>
<script src="/static/WebGL.js"></script>


<script src="/static/stats.min.js"></script>

<link rel="stylesheet" type="text/css" href="/static/css/game-ui.css">

<script src="/static/gameUI.js"></script>
<script src="/static/buildUI.js"></script>
<script src="/static/save.js"></script>


<script src="/static/map1.js"></script>
<script src="/static/pirateT.js"></script>
<script src="/static/cannonT.js"></script>
<script src="/static/ovi.js"></script>
<script src="/static/rap.js"></script>
<script src="/static/trex.js"></script>

<script type='text/javascript' src='/static/Tween.js'></script>
<script>

	//Global variables
	var scene, camera, renderer, controls, raycaster, mouse;


	var container, stats, countdown;

	//animation variables
	const mixers = [];
	const clock = new THREE.Clock();


	//Game map variables
	var gridT = [];
	var dinos = [];
	var towers = [];
	var projectiles = [];


	//var collisionSphere = []

	/*We need to RENDER the SCENE with a CAMERA*/
	function init() {

		//for stats
		//https://github.com/mrdoob/three.js/blob/master/examples/webgl_interactive_lines.html
		container = document.createElement('div');
		document.body.appendChild( container );

		var info = document.createElement( 'div' );
		info.style.position = 'absolute';
		info.style.top = '10px';
		info.stylewidth = '100%';
		info.style.textAlign = 'center';
		container.appendChild( info );


		//Create a new scene
		scene = new THREE.Scene();

		//Create a new camera
		//( FOV, aspect ratio, near clipping plane, far clipping plane )
		camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 500 );
		camera.position.set( 0, 10, -10 );
		camera.lookAt( menu );

		//Create the renderer
		renderer = new THREE.WebGLRenderer();

		//Set the render size
		renderer.setSize( window.innerWidth, window.innerHeight );

		renderer.setPixelRatio( window.devicePixelRatio );

		//for use with gltf/glb files
		renderer.gammaOutput = true;
		renderer.gammaFactor = 2.2;

		//Add the renderer to the html document
		document.body.appendChild( renderer.domElement );

			//three.js https://github.com/mrdoob/three.js/blob/master/examples/webgl_geometry_text_shapes.html
		window.addEventListener( 'resize', onWindowResize, false );

		/*Adding orbit controls. Allows camera to move*/
		controls = new THREE.OrbitControls( camera, renderer.domElement );

		stats = new Stats();
		container.appendChild( stats.dom );

		controls.target = new THREE.Vector3( 0, 5, 0 );

		//controls.target = menu.position;
		controls.enabled = true;
		//This sets the angle to which we can't look "under" the map
		controls.maxPolarAngle = Math.PI / 2;

		console.log("controls",controls);
		console.log("camera",camera);

		//for a static menu
		controls.enableKeys = false;

		//Raycaster
		raycaster = new THREE.Raycaster();
		mouse = new THREE.Vector2();

		//need to add a light so that colors and textures of loaded objects
		//will show up
		var ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
		scene.add(ambientLight);
		animate();
		//Load the menu

	//https://github.com/mrdoob/three.js/blob/master/examples/webgl_geometry_text_shapes.html

		menu();

		//play();
		//var dinos = [];
		//var ovi1 = addOviGLTF( scene, dinos );
		//dinos.push([ovi1,oviraptor]);

		//play()


		//requestAnimationFrame(render);


	//used to create a path that an object can follow
	//and will actually turn when following
	//works for an object created in int function, but not for dinos
	//rendered with the loader
	/*var numPoints = 50;

	var points = [];
	for(var i=0; i<map.path1.length; i++)
	{
		points.push(new THREE.Vector3(map.path1[i][0], 0, map.path1[i][1]));
	}

	spline = new THREE.CatmullRomCurve3(points);

	var smat = new THREE.LineBasicMaterial({color: 0xff00f0});
	var sgeo = new THREE.Geometry();
	var splinePoints = spline.getPoints(numPoints);
	for(var i=0; i<splinePoints.Length; i++){
		sgeo.vertices.push(splinePoints[i]);
	}

	var sline = new THREE.Line(sgeo, smat);
	scene.add(sline);

	sgeo = new THREE.BoxGeometry(2, 1, 3);
	smat = new THREE.MeshBasicMaterial({color: 0xff0000});
	sbox = new THREE.Mesh(sgeo, smat);
	sbox.position.x = -18;
	sbox.position.z = -18;
	sbox.position.y = 1;
	scene.add(sbox);*/

	//animate();
	//setInterval(moveBox, 10);
	}

	/*
	function moveDino(dino){
			dino.position.copy(spline.getPointAt(counter));

			tangent = spline.getTangentAt(counter).normalize();
			axis.crossVectors(up, tangent).normalize;
			var radians = Math.acos(up.dot(tangent));
			dino.quaternion.setFromAxisAngle(axis, radians);
			counter += 0.006;
	}

	//function that moves the box
	//actually turns the box when following the line
	//uses math and magic to calculate what direction to rotate
	//the box in
	function moveBox(){
			console.log("counter ", counter);
			sbox.position.copy(spline.getPointAt(counter));
			console.log("point ", spline.getPointAt(counter));
			console.log("position ", sbox.position);

			tangent = spline.getTangentAt(counter).normalize();
			console.log("tangent", tangent);
			axis.crossVectors(up, tangent).normalize;
			var radians = Math.acos(up.dot(tangent));
			sbox.quaternion.setFromAxisAngle(axis, radians);
			counter += 0.01;
	}*/










	//////////////////////////////////////////////


		//https://github.com/mrdoob/three.js/blob/master/examples/webgl_geometry_text_shapes.html

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}



//THIS COULD CAUSE PROBLEMS
	function render() {

		//controls.update();

		//requestAnimationFrame(animate);
		TWEEN.update();
		// 	renderer.render( scene, camera );
		controls.update();

		const delta = clock.getDelta();

		mixers.forEach( ( mixer ) => { mixer.update( delta ); } );

		renderer.render( scene, camera );

		//requestAnimationFrame( render );

	}

	//Adding a gltf loader for passing creating an object at a location
	//Derived from

	//added a health bar and made the dino and health bar into a group
	//const mixers = [];
	//const clock = new THREE.Clock();


//PREVIOUS
	// function dinoLoader( object, position, dinos ) {
	//
	// 	console.log("dinos", dinos);
	//
	// 	var position = {x: map.path1[0][0], y: 0, z: map.path1[0][1]};
	//
	// 	//create a target object with the x and z coordinates from the enemy path
	// 	var target = {};
	// 	target.x = [];
	// 	target.z = [];
	// 	target.y = 0;
	// 	for(var i=0; i<map.path1.length; i++)
	// 	{
	// 		//add the coordinates from the path
	// 		target.x.push(map.path1[i][0]);
	// 		target.z.push(map.path1[i][1]);
	// 	}
	//
	//
	// 	//https://github.com/mrdoob/three.js/blob/master/examples/webgl_animation_multiple.html
	// 	//https://github.com/mrdoob/three.js/blob/master/examples/webgl_animation_keyframes.html
	// 	const loader = new THREE.GLTFLoader();
	//
	// 	const onLoad = ( gltf, position ) => {
	//
	//
	// 		//var grouping;
	// 		// var geometry = new THREE.SphereGeometry( 8, 32, 32 );
	// 		// var material = new THREE.MeshBasicMaterial( { color: 0xffffff } );
	// 		// var sphere = new THREE.Mesh( geometry, material );
	// 		// scene.add(sphere);
	// 		// collisionSphere.push(sphere);
	//
	// 		var model = gltf.scene;
	//
	// 		model.position.copy( position );
	//
	// 		var animation = gltf.animations[ 0 ];
	//
	// 		var mixer = new THREE.AnimationMixer( model );
	// 		mixers.push( mixer );
	//
	// 		var action = mixer.clipAction( animation );
	// 		action.play();
	//
	// 		model.scale.set( 0.3, 0.3, 0.3 );
	//
	// 		model.name = "oviraptor";
	// 		model.position.x = map.path1[0][0];
	// 		model.position.z = map.path1[0][1];
	// 		model.userData.health = oviraptor.health;
	// 		model.userData.speed = oviraptor.speed;
	// 		model.userData.reward = oviraptor.reward;
	// 		model.type = "Object3D";
	// 		//model.computeBoundingSphere();
	//
	// 		console.log("loadDino model:", model);
	// 		//model.add(dino);
	// 		//group.add( sphere );
	// 		//group.add( model );
	// 		scene.add( model );
	// 		dinos.push([model,oviraptor]);
	// 		dinoPath( dinos, target );
	//
	//
	//
	// 	};


	function dinoLoader( object, position, dinos, delay ) {


		console.log("dinos", dinos);

		//two position variables were creating conflicts
		//dino does not get its position set individually now
		var position = {x: map.path1[0][0], y: 0, z: map.path1[0][1]};

		//create a target object with the x and z coordinates from the enemy path
		var target = {};
		target.x = [];
		target.z = [];
		target.y = 0;
		for(var i=0; i<map.path1.length; i++)
		{
			//add the coordinates from the path
			target.x.push(map.path1[i][0]);
			target.z.push(map.path1[i][1]);
		}


		//https://github.com/mrdoob/three.js/blob/master/examples/webgl_animation_multiple.html
		//https://github.com/mrdoob/three.js/blob/master/examples/webgl_animation_keyframes.html
		const loader = new THREE.GLTFLoader();

		const onLoad = ( gltf, position ) => {


			//var grouping;
			// var geometry = new THREE.SphereGeometry( 8, 32, 32 );
			// var material = new THREE.MeshBasicMaterial( { color: 0xffffff } );
			// var sphere = new THREE.Mesh( geometry, material );
			// scene.add(sphere);
			// collisionSphere.push(sphere);

			var model = gltf.scene;

			model.position.copy( position );

			var animation = gltf.animations[ 0 ];

			var mixer = new THREE.AnimationMixer( model );
			mixers.push( mixer );

			var action = mixer.clipAction( animation );
			action.play();

			model.scale.set( 0.3, 0.3, 0.3 );

			model.name = "oviraptor";
			model.position.x = map.path1[0][0];
			model.position.z = map.path1[0][1];
			model.userData.health = oviraptor.health;
			model.userData.speed = oviraptor.speed;
			model.userData.reward = oviraptor.reward;
			model.type = "Object3D";


			//creating the health bar
			//it has 4 sections that could equal 1/4 of the health of the dino
			var barGemetry = new THREE.BoxGeometry(.25, .25, 1, 1, 1, 4);
			var barMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
			var healthBar = new THREE.Mesh(barGemetry, barMaterial);
			healthBar.position.x = map.path1[0][0];
			healthBar.position.z = map.path1[0][1];

			//make bar float above the dino
			healthBar.position.y = 3;
			//scene.add(healthBar);
			//model.add(healthBar);

			/*group = new THREE.Group();
			group.add(model);
			group.add(healthBar);*/

			//create a new group out of a THREE.Object3D
			//this allows the dino and bar to be moved together
			//the dino and health bar position are not set individually
			//but the group's position is set instead
			dinogroup = new THREE.Group();
			dinogroup.add(model);
			dinogroup.add(healthBar);
			console.log("start pos", map.path1[0][0]);
			//dinogroup.position.x = map.path1[0][0];
			//dinogroup.position.z = map.path1[0][1];

			console.log("loadDino model:", model);
			//model.add(dino);
			scene.add( dinogroup );

			dinos.push([model,oviraptor]);
			console.log("group ", dinogroup);
			console.log("group pos ", dinogroup.position);
			dinoPath( dinogroup, oviraptor.speed, target, delay );
			//moveDino(model);



		};

		const onProgress = () => {};

		const onError = (errorMessage ) => {

			console.log( errorMessage );

		};

		loader.load( object, gltf => onLoad( gltf, position ), onProgress, onError );

	}

	//Creating the opening view of the game's menu
	function menu() {

		var canvas = document.createElement('canvas');
		canvas.width = 256;
		canvas.height = 256;
		var context = canvas.getContext('2d');
		context.fillStyle = '#ff0000';
		context.textAlign = 'center';
		context.font = '24px Arial';
		context.fillText("Start Game", 175, 175);
		var amap = new THREE.Texture(canvas);
		amap.needsUpdate = true;

		var mat = new THREE.SpriteMaterial({
			map: amap,
			transparent: false,
			color: 0xffffff
		});

		var sp = new THREE.Sprite(mat);
		sp.scale.set(10, 10, 1);
		sp.name = "playme";
		sp.position.y = 11;
		sp.position.x = 2;
		scene.add(sp);
		gridT.push(sp);
		console.log("sprite", sp);

		var canvas2 = document.createElement('canvas');
		canvas2.width = 600;
		canvas2.height = 256;
		var context2 = canvas2.getContext('2d');
		context2.fillStyle = '#ff0000';
		context2.textAlign = 'center';
		context2.font = '16px Arial';
		context2.fillText("Team Nunki: Christopher Frenchi, Jonathan Ruby, Ruben Torres", 300, 175);
		var amap2 = new THREE.Texture(canvas2);
		amap2.needsUpdate = true;

		var mat2 = new THREE.SpriteMaterial({
			map: amap2,
			transparent: false,
			color: 0xffffff
		});

		var credits = new THREE.Sprite(mat2);
		credits.scale.set(10,10,1);
		credits.name = "credits";
		credits.position.y = 4;
		credits.position.x = 0;
		scene.add(credits);
		gridT.push(credits);

		//disables users ability to move around menu
		controls.enabled = false;

		/*Adding a play button*/

			//Creating a plane
		var buttonGeoPlay = new THREE.PlaneBufferGeometry( 5, 3 );
		console.log( "buttonGeoPlay", buttonGeoPlay );
		buttonGeoPlay.rotateX( 2.677945044588987 );
		buttonGeoPlay.rotateY( -1 );
		buttonGeoPlay.rotateZ( Math.PI );

			//Creating material
		var buttonMatPlay = new THREE.MeshBasicMaterial( { color: 0xffffff } );

			//Creating a mesh
		var playButton = new THREE.Mesh( buttonGeoPlay, buttonMatPlay );

			//Setting variables
		playButton.position.y = 6;
		playButton.rotation.y = -1;
		playButton.name = "play";

			//Pushing to the tile array
		//gridT.push( playButton );

		/*Adding a Credits button*/

			//Creating a plane
		var buttonGeoCredits = new THREE.PlaneBufferGeometry( 3, 1 );
		console.log( "buttonGeoCredits", buttonGeoCredits );
		buttonGeoCredits.rotateX( 2.677945044588987 );
		buttonGeoCredits.rotateY( -1 );
		buttonGeoCredits.rotateZ( Math.PI );

			//Creating material
		var buttonMatCredits = new THREE.MeshBasicMaterial( { color: 0xff00ff } );

			//Creating a mesh
		var creditsButton = new THREE.Mesh( buttonGeoCredits, buttonMatCredits );

			//Setting variables
		creditsButton.position.y = 2;
		creditsButton.rotation.y = -1;
		creditsButton.name = "credits";

			//Pushing to the tile array
		//gridT.push( creditsButton );

		//Add buttons to the scene
		//scene.add( playButton );
		//scene.add( creditsButton );

		//Remove right click menu and add object clicking
		document.addEventListener( 'contextmenu', function( event ) { event.preventDefault() }, false );
		document.addEventListener( 'click', menuSelect, false );

		var menuScope = this;

		function menuSelect( event ) {

			console.log( "mouse: ", event );

			if( event.button == 0 ) {

				event.preventDefault();
				event.stopPropagation();

				mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( gridT );

				console.log( "intersects", intersects);

				if( intersects.length != 0 ) {

					if(intersects[0].object.name == "playme") {

						document.removeEventListener( 'click', menuSelect, false );

						scene.remove(intersects[0].object);

						setTimeout( function() {

							gridT.pop();
							gridT.pop();

							scene.remove( playButton );
							scene.remove( creditsButton );
							scene.remove(sp);
							scene.remove(credits);
							//scene.remove(newSp);

							buttonGeoPlay.dispose();
							buttonGeoCredits.dispose();
							mat.dispose();
							mat2.dispose();
							//newMat.dispose();

							buttonMatPlay.dispose();
							buttonMatCredits.dispose();

						}, 500 );

						//Play the game
						setTimeout( function() { play(); }, 600 );

					} else if ( intersects[0].object.name == "credits" ) {

						//Show credit screen

						/*scene.remove(credits);
						mat2.dispose();

						sp.position.y = -1;

						var canvases = [];
						var pos = 6;
						var swidth = 600;
						var sheight = 256;
						//for(var i=0; i<4; i++)
						//{
							var newCanvas = document.createElement('canvas');
							newCanvas.width = swidth;
							newCanvas.height = sheight;
							var newContext = newCanvas.getContext('2d');
							newContext.fillStyle = '#ff0000';
							newContext.textAlign = 'center';
							newContext.font = '16px Arial';
							newContext.fillText("Team Nunki: Christopher Frenchi, Jonathan Ruby, Ruben Torres", swidth/2, sheight/2);
							var amap = new THREE.Texture(newCanvas);
							amap.needsUpdate = true;

							var newMat = new THREE.SpriteMaterial({
								map: amap,
								transparent: false,
								color: 0xffffff
							});

							var newSp = new THREE.Sprite(newMat);
							newSp.scale.set(14, 14, 1);
							newSp.position.y = 8;
							newSp.position.x = 0;
							scene.add(newSp);
							//canvases.push(newSp);
							//pos+=2;
						//}
						/*for(var i=0; i<4; i++)
					{
						scene.add(canvases[i]);
					}*/
					}
					

				}

			}

		}

		console.log("menu");

	}

	//Creating the game engine and functionality
	function play() {

		checkCookie();
		/*

		Game variables to be set by rule file:

		Total Waves = totWaves
		Current Wave = curWave
		Time between Waves = timeXwave
		Player lives = lives

		Player coins = coins



		var towerClock = new THREE.Clock();

		clock.startTime;

		*/

		//add a countdown timer
		countdown = document.createElement('div');
		countdown.style.position = 'absolute';
		countdown.id = 'countdown';
		countdown.style.width = "200px";
		countdown.style.height = '50px';
		countdown.style.background = 'green';
		countdown.style.top = '50px';
		countdown.style.left = '50%';
		countdown.style.textAlign = 'center';
		document.body.appendChild(countdown);

		var timeleft = 10;
		var countdownTimer = setInterval(function(){
			document.getElementById("countdown").innerHTML = "Start in " + timeleft;
			timeleft -= 1;
			if(timeleft == -1){
				document.getElementById("countdown").innerHTML = "Start"
			}
			else if(timeleft < -1){
				clearInterval(countdownTimer);
				document.getElementById("countdown").style.display = "none";
			}
		}, 1000);
		var totWaves, timeXwave;
		var coins = 100;
		var curWave = 1;
		var lives = 3;
		initGameUI(coins, lives, curWave);


		//allows user to move the map
		controls.enabled = true;

		/*Adding a plane to the scene*/
		var planeGeo = new THREE.PlaneBufferGeometry( 4, 4 );
		planeGeo.rotateX( - Math.PI / 2 );

		//Testing maps0.js
		//var jsMap = maps;

		//console.log(".js MAP: ",jsMap.mapArray[0].name, jsMap.mapArray[0].map);


		//Added a map as an array
		var map0 = ['a', 'b', 'a', 'b'];
		var map1 = ['b', 'a', 'b', 'a'];
		var map2 = ['a', 'b', 'a', 'b'];
		var map3 = ['b', 'a', 'b', 'a'];
		var map4 = ['a', 'b', 'a', 'b'];
		var m = [map0, map1, map2, map3, map4];





		var gridTiles = [];

		var gridTiles = [];
		var path = [];
		function addTiles(m){
			console.log("adding tiles", m);
			//gets the length of a single array (map0 a,b,a,b)
			var arrZ = m[0].length;
			//get the number of arrays (map0, map1, map2, map3)
			var arrX = m.length;
			console.log("arr", arrX, arrZ);

			//
			for( var i = 0, x = -(arrX/2); x < (arrX/2); x++, i++ ){
				var gridRow = [];
				for( var j = 0, z= -(arrZ/2); z < (arrZ)/2; z++, j++ ){
					console.log("\n",x,z, m[i][j], i, j);

					//Creating new variable plane every instance and adding to
					//the scene. Position offset by 4 because it seems to be the
					//internal size of that object
					if(m[i][j] == '.'){
						var plane = new THREE.Mesh( planeGeo, new THREE.MeshBasicMaterial( { color: 0x416600 } ) );
						plane.position.x = 4*x+2;
						plane.position.z = 4*z+2;
						//name need for raycaster build logic
						plane.name = "buildable";
						gridRow.push( plane );
						//for testing raycaster
						gridT.push( plane );
						scene.add( plane );
					}
					else if (m[i][j] == '*'){
						var plane = new THREE.Mesh( planeGeo, new THREE.MeshBasicMaterial( { color: 0xf2d527 } ) );
						plane.position.x = 4*x+2;
						plane.position.z = 4*z+2;
						gridRow.push( plane );
						path.push(plane);
						//for testing raycaster
						gridT.push( plane );
						scene.add( plane );
					}
					else if (m[i][j] == 's'){
						var plane = new THREE.Mesh( planeGeo, new THREE.MeshBasicMaterial( { color: 0x4568c2 } ) );
						plane.position.x = 4*x+2;
						plane.position.z = 4*z+2;
						plane.name = "start";
						gridRow.push( plane );
						console.log("start ", plane);
						//for testing raycaster
						gridT.push( plane );
						scene.add( plane );
					}
					else if (m[i][j] == 'e'){
						var plane = new THREE.Mesh( planeGeo, new THREE.MeshBasicMaterial( { color: 0xa12b0d } ) );
						plane.position.x = 4*x+2;
						plane.position.z = 4*z+2;
						plane.name = "end";
						gridRow.push( plane );
						console.log("end", plane);
						//for testing raycaster
						gridT.push( plane );
						scene.add( plane );
					}
				}
				gridTiles.push( gridRow );
				console.log("gridRow", gridRow );
			}
		}
				//addTiles(m);
		addTiles(map.level1);
		console.log("path ", path);

		//create a line to show the path
		var material = new THREE.LineBasicMaterial({
			color: 0x0000ff
		});


		var geometry = new THREE.Geometry();
		/*geometry.vertices.push(
			new THREE.Vector3( path[0].position.x, 0, path[0].position.z ),
			new THREE.Vector3( path[1].position.x, 0, path[1].position.z ),
		);*/

		//convert the path to usable coordinates
		makePath(map.path1, map.level1x, map.level1z);

		//add the vertices to the path
		for(var i=0; i<map.path1.length; i++)
		{
			geometry.vertices.push(
			new THREE.Vector3( map.path1[i][0], 0, map.path1[i][1] )
			)
		}

		//add the line of the path to the scene
		//the line is not nescessary for the movement of the cube, but makes the
		//path easier to see
		var line = new THREE.Line( geometry, material );
		scene.add( line );

		//array to hold the current dinos in play
		//var dinos = [];

		//add an oviraptor

		//addOviGLTF( scene, dinos );
		//addOviGLTF( scene, dinos );

		/////////////////////////////////////////////////////
		////////////////////////////////////////////////////
		//start the waves
		var delay = 10000;
		for(var i=0; i<3; i++)
		{
			addOviGLTF(scene, dinos, delay);
			delay += 500;
		}

		delay += 10000;

		for(var i=0; i<4; i++)
		{
			addOviGLTF(scene, dinos, delay);
			delay += 500;
		}

		delay += 10500;

		for(var i=0; i<5; i++)
		{
			addOviGLTF(scene, dinos, delay);
			delay += 500;
		}

		//addOvi(scene, dinos);
		//addRaptor(scene, dinos);
		//addTrex(scene, dinos);
		// console.log("dinos", dinos);
		//
		// var position = {x: map.path1[0][0], y: 0, z: map.path1[0][1]};
		//
		// //create a target object with the x and z coordinates from the enemy path
		// var target = {};
		// target.x = [];
		// target.z = [];
		// target.y = 0;
		// for(var i=0; i<map.path1.length; i++)
		// {
		// 	//add the coordinates from the path
		// 	target.x.push(map.path1[i][0]);
		// 	target.z.push(map.path1[i][1]);
		// }

		//create a new tween to move the dinos
		//console.log("speed", dinos[0][1].speed);
		//setTimeout Work around... we need to be able to run this function once
		//all dinos are loaded...
		//Wave setup?
		//setTimeout(function() {

		//}, 1500);

		console.log("dinos array", dinos );

		//array to hold created towers
		//var towers = [];

		function tileHover( event ) {

		}

		/***********************************
		addTower function now in pirateT.js
		************************************/

		//To add towers, use double click

		document.addEventListener( 'dblclick', onDocumentMouseDown, false );

		function onDocumentMouseDown( event ) {
			event.preventDefault();
			mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

			raycaster.setFromCamera( mouse, camera );
			var intersects = raycaster.intersectObjects( gridT );

			if(intersects[0].object.name == "buildable") {
				scene.remove(intersects[0].object);
				//addpirateT( intersects[0].object.position, scene, gridT, towers );
			}
		}

		function onDocumentMouseDown( event ) {

			event.preventDefault();

			mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

			raycaster.setFromCamera( mouse, camera );

			var intersects = raycaster.intersectObjects( gridT );

			console.log(intersects);

			if(intersects[0].object.name == "buildable") {


				var possibleCoins = 0;

				//shows build options for player's current coin at this location (need to change first param to coin
				//last param to cost of last tower

				viewBuildMenu(coins, pirateT.cost, cannonT.cost, cannonT.cost);

				//remove the previous click event (which was to build for last location)
				document.getElementById("build-musket-button").removeEventListener("click", clickMusket);
				document.getElementById("build-cannon-button").removeEventListener("click", clickCannon);
				document.getElementById("build-net-button").removeEventListener("click", clickNet);

				//new build functions at this location
				clickMusket = function () {
						console.log("Clicked Musket Tower")
  						clearBuildMenu();
						possibleCoins = coins - pirateT.cost;
						updateGameUIbar("coins", possibleCoins);
						intersects[0].object.name = "tower";
						addpirateT( intersects[0].object.position, scene, gridT, towers );
						};

				clickCannon = function() {
						console.log("Clicked Cannon Tower")
  						clearBuildMenu();
						possibleCoins = coins - cannonT.cost;
						updateGameUIbar("coins", possibleCoins);
						intersects[0].object.name = "tower";
						addcannonT( intersects[0].object.position, scene, gridT, towers );
						console.log("towers", towers);
						};

				clickNet = function() {
						console.log("Clicked Net Tower")
  						clearBuildMenu();
						possibleCoins = coins - pirateT.cost;
						updateGameUIbar("coins", possibleCoins);
						intersects[0].object.name = "tower";
						addcannonT( intersects[0].object.position, scene, gridT, towers );
						};


				//new events for on click at this location
				document.getElementById("build-musket-button").addEventListener("click", clickMusket);
				document.getElementById("build-cannon-button").addEventListener("click", clickCannon);
				document.getElementById("build-net-button").addEventListener("click", clickNet);



// THIS COULD CASE PROBLEMS

				/*******************************************************
				change tower add function to see other types of towers
				*******************************************************/
				// addcannonT( intersects[0].object.position, scene, gridT, towers );
				//
				// //testing tower locations for raycasting
				// if ( towers.length == 1 ) {
				// 	console.log( "dinos ", dinos );
				// 	//attack(towers, dinos);
				// }
				// else if ( towers.length > 1 ) {
				// 	var tc = towers[0].children;
		    //   console.log( "towers",towers[0] );
		    //   console.log( "t", tc[0].position );
				//
				// }


			}
			else {

				console.log("Can not build", intersects[0].object.name);

			}
		}

	}

	var points = [];
	for(var i=0; i<map.path1.length; i++)
	{
		points.push(new THREE.Vector3(map.path1[i][0], 0, map.path1[i][1]));
	}

	spline = new THREE.CatmullRomCurve3(points);

	// function that sends a dino down the path
	// target is the path determined by the map
	// delay is determined by the wave
	// uses onUpdate to change the rotation of the dino in relation to the y axis
	function dinoPath(dino, speed, target, delay)
	{
		//var count = 0;
		// for( var d = 0; d < dino.length; d++ ){
		//
		//
		// }
		console.log("dino in dinoPath", dino);
		console.log(dino.children);
		console.log(dino.children.length);
		//dino.children because we are passing in a group
		for( var dc = 0; dc < dino.children.length; dc++){
		//
		//
		//
		//
		dino.children[dc].rotation.y = 300;
		// // //console.log("dino qurt",dino.quaternion);
		// // //var tan = new THREE.Vector3();
		// // //var ax = new THREE.Vector3();
		// // //var u = new THREE.Vector3(0,0,1);
		var move = new TWEEN.Tween(dino.children[0].position)
			.to(target, speed).delay(delay)
			.onUpdate(function(){
				//console.log("counter", counter);
				/*tan = spline.getTangentAt(count).normalize();
				ax.crossVectors(u, tan).normalize;
				var radians = Math.acos(u.dot(tan));
				dino.quaternion.setFromAxisAngle(ax, radians);
				count += 1;*/
				//console.log("tan", tan);
				//console.log("ax", ax);

				//to the left, good
				if(dino.children[0].position.z == -6 && dino.children[0].position.x > -18 && dino.children[0].position.x < -6){
					dino.children[0].rotation.y = 0;
				}

				//down, good
				else if(dino.children[0].position.x == -6 && dino.children[0].position.z < -6 && dino.children[0].position.z > -10){
					dino.children[0].rotation.y = 89.5;
				}

				//to the left, good
				else if(dino.children[0].position.z == -10 && dino.children[0].position.x > -5 && dino.children[0].position.x < 2){
					dino.children[0].rotation.y = 0;
				}

				//up, good
				else if(dino.children[0].position.x == 2 && dino.children[0].position.z > -10 && dino.children[0].position.z < -6){
					dino.children[0].rotation.y = 300;
				}

				//left, good
				else if(dino.children[0].position.z == -6 && dino.children[0].position.x > 2 && dino.children[0].position.x < 6){
					dino.children[0].rotation.y = 0;
				}

				//up, good
				else if(dino.children[0].position.x == 6 && dino.children[0].position.z > -5 && dino.children[0].position.z < 10){
					dino.children[0].rotation.y = 300;
				}

				//left, good
				else if(dino.children[0].position.z == 10 && dino.children[0].position.x > 6 && dino.children[0].position.x < 10){
					dino.children[0].rotation.y = 0;
				}

				//down, good
				else if(dino.children[0].position.x == 10 && dino.children[0].position.z < 10 && dino.children[0].position.z > 2){
					dino.children[0].rotation.y = 89.5;
				}

				//left, good
				else if(dino.children[0].position.z == 2 && dino.children[0].position.x > 10 && dino.children[0].position.x < 18){
					dino.children[0].rotation.y = 0;
				}

				//up, disappears
				else if(dino.children[0].position.x == 18 && dino.children[0].position.z > 2 && dino.children[0].position.z < 18){
					dino.children[0].rotation.y = 300;
				}
				//console.log("dino pos ", dino.position);

			})
			.start();
			//removes the dino from the scene once it has reached the end
			// move.onComplete(function(){
			// 	scene.remove(dino);
			// });


				//health bar


		var healthmove = new TWEEN.Tween(dino.children[1].position)
			.to(target, speed).delay(delay)
			.onUpdate(function(){
				if(dino.children[1].position.z == -6 && dino.children[1].position.x > -18 && dino.children[1].position.x < -6){
					dino.children[1].rotation.y = 0;
				}

				//down, good
				else if(dino.children[1].position.x == -6 && dino.children[1].position.z < -6 && dino.children[1].position.z > -10){
					dino.children[1].rotation.y = 89.5;
				}

				//to the left, good
				else if(dino.children[1].position.z == -10 && dino.children[1].position.x > -5 && dino.children[1].position.x < 2){
					dino.children[1].rotation.y = 0;
				}

				//up, good
				else if(dino.children[1].position.x == 2 && dino.children[1].position.z > -10 && dino.children[1].position.z < -6){
					dino.children[1].rotation.y = 300;
				}

				//left, good
				else if(dino.children[1].position.z == -6 && dino.children[1].position.x > 2 && dino.children[1].position.x < 6){
					dino.children[1].rotation.y = 0;
				}

				//up, good
				else if(dino.children[1].position.x == 6 && dino.children[1].position.z > -5 && dino.children[1].position.z < 10){
					dino.children[1].rotation.y = 300;
				}

				//left, good
				else if(dino.children[1].position.z == 10 && dino.children[1].position.x > 6 && dino.children[1].position.x < 10){
					dino.children[1].rotation.y = 0;
				}

				//down, good
				else if(dino.children[1].position.x == 10 && dino.children[1].position.z < 10 && dino.children[1].position.z > 2){
					dino.children[1].rotation.y = 89.5;
				}

				//left, good
				else if(dino.children[1].position.z == 2 && dino.children[1].position.x > 10 && dino.children[1].position.x < 18){
					dino.children[1].rotation.y = 0;
				}

				//up, disappears
				else if(dino.children[1].position.x == 18 && dino.children[1].position.z > 2 && dino.children[1].position.z < 18){
					dino.children[1].rotation.y = 300;
				}
			})
			.start();
		//removes the dino from the scene once it has reached the end
		healthmove.onComplete(function(){
				scene.remove(dino);
		});
		//
		}

	}
	/*function dinoPath( dinos, target, delay ){
	for(var i=0; i<dinos.length; i++)
	{
		console.log("dino length = ", dinos.length, i);
		console.log("delay", delay);
		var moveOvi = new TWEEN.Tween(dinos[i][0].position)
			.to(target, dinos[i][1].speed).delay(delay)
			.start();
		moveOvi.repeat(1000);
		console.log( "moveOvi", moveOvi );
	}
}*/
	// function addOviGLTF( scene, dinos ){
	//   console.log( "dinos gltf", dinos );
	//   const oviPosition = new THREE.Vector3( 0, 0, 0 );
	// 	modelLoader( '/static/dinos/raptor1.glb', oviPosition );
	//   //scene.add(newOvi);
	//   //dinos.push([newOvi,oviraptor]);
	// }

//PREVIOUS
	// function dinoPath( dinos, target ){
	// 	for(var i=0; i<dinos.length; i++)
	// 	{
	// 		console.log("dino length = ", dinos.length, dinos);
	// 		var moveOvi = new TWEEN.Tween(dinos[i][0].position)
	// 			.to(target, dinos[i][1].speed)
	// 			.start();
	// 		moveOvi.repeat(1000);
	// 		console.log( "moveOvi", moveOvi );
	// 	}
	// }


	init();

	/*Rendering the scene https://www.august.com.au/blog/animating-scenes-with-webgl-three-js/*/
	//animate();

	function animate(){


		if( towers.length >= 1 ){
			for( var i = 0; i < towers.length; i++ ) {
	    	//console.log("for i", i );
	      var tc = towers[i].children;
	      for( var j = 0; j < tc.length; j=j+2) {
					attack( towers, dinos );
	        //radiusCheck( tc[j+1].userData.attackRadius, tc[j].position)
	        //console.log("or herer?");
	      };
			};

			//attack( towers, dinos );
		}
		if( projectiles.length > 0 ){
			for( var p = 0; p < projectiles.length; p++){
				//console.log("projectile", projectiles[p].userData);
				//projectiles[p].position.y = 2;
				projectiles[p].position.y -= .2;
				//projectiles[p].position.x = 1;
				//projectiles[p].position.z = 1;
				// var distanceV = new THREE.Vector3();
				if ( projectiles[p].position.x > projectiles[p].userData.x ){
					//console.log("************",projectiles[p].userData.x, projectiles[p].position.x);
					projectiles[p].position.x -= .75;//projectiles[p].userData.x;
					//projectiles[p].position.y -= .2;
				}
				if ( projectiles[p].position.z > projectiles[p].userData.z ){
					projectiles[p].position.z -= .75;//projectiles[p].userData.z;
					//projectiles[p].position.y -= .2;

				}
				if ( projectiles[p].position.x < projectiles[p].userData.x){
					//console.log("here");
					projectiles[p].position.x += .75;//projectiles[p].userData.x;
					//projectiles[p].position.y -= .2;

				}
				if ( projectiles[p].position.z < projectiles[p].userData.z){
					projectiles[p].position.z += .75;

				}

				projectiles[p].position.y -= .2;
				// distanceV.x = projectiles[p].position.x - projectiles[p].userData.x;
				// distanceV.y = projectiles[p].position.y - projectiles[p].userData.y;
				// distanceV.z = projectiles[p].position.z - projectiles[p].userData.z;
				// distanceV.normalize();
				// projectiles[p].position.copy( distanceV );
				if (projectiles[p].position.y <= 0){

					scene.remove(projectiles[p]);
					//console.log("removing proj", projectiles[p].uuid);
					//console.log("remaining", projectiles);
					projectiles.splice(p, 1);

				}
			}

		}

		requestAnimationFrame(animate);
		TWEEN.update();
		const delta = clock.getDelta();
		mixers.forEach( ( mixer ) => {
			mixer.update( delta );
		});
		renderer.render( scene, camera );
		controls.update();
		stats.update();
	}

	/*

	Resources:
	https://www.august.com.au/blog/animating-scenes-with-webgl-three-js/
	https://threejs.org/docs/#manual/en/introduction/Creating-a-scene



	*/

</script>
