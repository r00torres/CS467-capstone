<script src="/static/three.js"></script>

<script src="/static/OrbitControls.js"></script>
<script src="/static/OBJLoader.js"></script>
<script src="/static/MTLLoader.js"></script>
<script src="/static/WebGL.js"></script>

<script src="/static/gameUI.js"></script>
<script src="/static/buildUI.js"></script>

<script src="/static/map1.js"></script>
<script src="/static/pirateT.js"></script>
<script src="/static/cannonT.js"></script>
<script src="/static/ovi.js"></script>
<script src="/static/rap.js"></script>
<script src="/static/trex.js"></script>

<script type='text/javascript' src='/static/Tween.js'></script>

<script>
	
	//Global variables
	var scene, camera, renderer, controls, raycaster, mouse;
	
	//Game variables
	var gridT = [];

	/*We need to RENDER the SCENE with a CAMERA*/
	function init() {

		//Create a new scene
		scene = new THREE.Scene();

		//Create a new camera
		//( FOV, aspect ratio, near clipping plane, far clipping plane )
		camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 500 );
		camera.position.set( 0, 10, -10 );
		//camera.lookAt( menu );

		//Create the renderer
		renderer = new THREE.WebGLRenderer();

		//Set the render size
		renderer.setSize( window.innerWidth, window.innerHeight );

		//Add the renderer to the html document
		document.body.appendChild( renderer.domElement );

			//three.js https://github.com/mrdoob/three.js/blob/master/examples/webgl_geometry_text_shapes.html
		window.addEventListener( 'resize', onWindowResize, false );

		renderer.render(scene, camera);


		/*Adding orbit controls. Allows camera to move*/
		controls = new THREE.OrbitControls( camera, renderer.domElement );
		controls.target = new THREE.Vector3( 0, 5, 0 );

		//controls.target = menu.position;
		controls.enabled = true;
		//This sets the angle to which we can't look "under" the map
		controls.maxPolarAngle = Math.PI / 2;

		console.log("controls",controls);
		console.log("camera",camera);

		//controls.enableKeys = false;
		
		//Raycaster
		raycaster = new THREE.Raycaster();
		mouse = new THREE.Vector2();
		
		//need to add a light so that colors and textures of loaded objects
		//will show up
		var ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
		scene.add(ambientLight);
		
		//Load the menu
		//menu();
		play()
		
		
		requestAnimationFrame(render);



	}


		//https://github.com/mrdoob/three.js/blob/master/examples/webgl_geometry_text_shapes.html
	function onWindowResize() {
	
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		
		renderer.setSize( window.innerWidth, window.innerHeight );
		
	}




	function render() {

		controls.update();

		renderer.render( scene, camera );

		requestAnimationFrame( render );

	}





	function menu() {

		//disables users ability to move around menu
		controls.enabled = false;
		
		
		
		/*Adding a play button*/
		
			//Creating a plane
		var buttonGeoPlay = new THREE.PlaneBufferGeometry( 5, 3 );
		console.log( "buttonGeoPlay", buttonGeoPlay );
		buttonGeoPlay.rotateX( 2.677945044588987 );
		buttonGeoPlay.rotateY( -1 );
		buttonGeoPlay.rotateZ( Math.PI );

			//Creating material
		var buttonMatPlay = new THREE.MeshBasicMaterial( { color: 0xffffff } );
		
			//Creating a mesh
		var playButton = new THREE.Mesh( buttonGeoPlay, buttonMatPlay );
		
			//Setting variables
		playButton.position.y = 6;
		playButton.rotation.y = -1;
		playButton.name = "play";
			
			//Pushing to the tile array
		gridT.push( playButton );
		
		
		
		/*Adding a Credits button*/
		
			//Creating a plane
		var buttonGeoCredits = new THREE.PlaneBufferGeometry( 3, 1 );
		console.log( "buttonGeoCredits", buttonGeoCredits );
		buttonGeoCredits.rotateX( 2.677945044588987 );
		buttonGeoCredits.rotateY( -1 );
		buttonGeoCredits.rotateZ( Math.PI );

			//Creating material
		var buttonMatCredits = new THREE.MeshBasicMaterial( { color: 0xff00ff } );
		
			//Creating a mesh
		var creditsButton = new THREE.Mesh( buttonGeoCredits, buttonMatCredits );
		
			//Setting variables
		creditsButton.position.y = 2;
		creditsButton.rotation.y = -1;
		creditsButton.name = "credits";
			
			//Pushing to the tile array
		gridT.push( creditsButton );



		//Add buttons to the scene
		scene.add( playButton );
		scene.add( creditsButton );
		
		
		//Remove right click menu and add object clicking
		document.addEventListener( 'contextmenu', function( event ) { event.preventDefault() }, false );
		document.addEventListener( 'click', menuSelect, false );
		
		var menuScope = this;
		

		function menuSelect( event ) {
			
			console.log( "mouse: ", event );
		
			if( event.button == 0 ) {
		
				event.preventDefault();
				event.stopPropagation();
				
				mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

				raycaster.setFromCamera( mouse, camera );
				
				var intersects = raycaster.intersectObjects( gridT );

				console.log( "intersects", intersects);
				
				if( intersects.length != 0 ) {
				
					if(intersects[0].object.name == "play") {
					
						document.removeEventListener( 'click', menuSelect, false );
					
						scene.remove(intersects[0].object);
						
						setTimeout( function() { 
						
							gridT.pop();
							gridT.pop();
							
							scene.remove( playButton ); 
							scene.remove( creditsButton );
							
							buttonGeoPlay.dispose();
							buttonGeoCredits.dispose();
							
							buttonMatPlay.dispose();
							buttonMatCredits.dispose();									
							
						}, 500 );

						//Play the game
						setTimeout( function() { play(); }, 600 ); 
						
					} else if ( intersects[0].object.name == "credits" ) {
					
						//Show credit screen
						
						
					
					}
					
				}
			
			}
			
		}

		console.log("menu");

	}






	//!!!!!!!!may want to add parameters to pass in map and rules to play?
	
	/*

	function will take the map array and add it to the scene

	Iterate through the arrays
	i, j will be used in order to offset the positions

	*/
	function play() {

		initGameUI();
		
		/*
		
		Game variables to be set by rule file:
		
		Total Waves = totWaves
		Current Wave = curWave
		Time between Waves = timeXwave
		Player lives = lives
		
		*/
		var totWaves, curWave, timeXwave, lives;


		//allows user to move the map
		controls.enabled = true;

		/*Adding a plane to the scene*/
		var planeGeo = new THREE.PlaneBufferGeometry( 4, 4 );
		planeGeo.rotateX( - Math.PI / 2 );

		//Testing maps0.js
		//var jsMap = maps;

		//console.log(".js MAP: ",jsMap.mapArray[0].name, jsMap.mapArray[0].map);


		//Added a map as an array
		var map0 = ['a', 'b', 'a', 'b'];
		var map1 = ['b', 'a', 'b', 'a'];
		var map2 = ['a', 'b', 'a', 'b'];
		var map3 = ['b', 'a', 'b', 'a'];
		var map4 = ['a', 'b', 'a', 'b'];
		var m = [map0, map1, map2, map3, map4];


		
		
		
		var gridTiles = [];
		
		var gridTiles = [];
var path = [];
function addTiles(m){
	console.log("adding tiles", m);
	//gets the length of a single array (map0 a,b,a,b)
	var arrZ = m[0].length;
	//get the number of arrays (map0, map1, map2, map3)
	var arrX = m.length;
	console.log("arr", arrX, arrZ);
	
	//
	for( var i = 0, x = -(arrX/2); x < (arrX/2); x++, i++ ){
		var gridRow = [];
		for( var j = 0, z= -(arrZ/2); z < (arrZ)/2; z++, j++ ){
			console.log("\n",x,z, m[i][j], i, j);
					
			//Creating new variable plane every instance and adding to
			//the scene. Position offset by 4 because it seems to be the
			//internal size of that object
			if(m[i][j] == '.'){ 
				var plane = new THREE.Mesh( planeGeo, new THREE.MeshBasicMaterial( { color: 0x416600 } ) );
				plane.position.x = 4*x+2;
				plane.position.z = 4*z+2;

				//name need for raycaster build logic
				plane.name = "buildable";

				gridRow.push( plane );

				//for testing raycaster
				gridT.push( plane );
				scene.add( plane );
			} 

			else if (m[i][j] == '*'){
				var plane = new THREE.Mesh( planeGeo, new THREE.MeshBasicMaterial( { color: 0xf2d527 } ) );
				plane.position.x = 4*x+2;
				plane.position.z = 4*z+2;
				gridRow.push( plane );

				path.push(plane);

				//for testing raycaster
				gridT.push( plane );
				scene.add( plane );
			}

			else if (m[i][j] == 's'){
				var plane = new THREE.Mesh( planeGeo, new THREE.MeshBasicMaterial( { color: 0x4568c2 } ) );
				plane.position.x = 4*x+2;
				plane.position.z = 4*z+2;
				plane.name = "start";
				gridRow.push( plane );
				console.log("start ", plane);

				//for testing raycaster
				gridT.push( plane );
				scene.add( plane );
			}	

			else if (m[i][j] == 'e'){
				var plane = new THREE.Mesh( planeGeo, new THREE.MeshBasicMaterial( { color: 0xa12b0d } ) );
				plane.position.x = 4*x+2;
				plane.position.z = 4*z+2;
				plane.name = "end";
				gridRow.push( plane );
				console.log("end", plane);

				//for testing raycaster
				gridT.push( plane );
				scene.add( plane );
			}					
		}
		gridTiles.push( gridRow );
		console.log("gridRow", gridRow );
	}
}

		//addTiles(m);
addTiles(map.level1);
console.log("path ", path);

//create a line to show the path
var material = new THREE.LineBasicMaterial({
	color: 0x0000ff
});


var geometry = new THREE.Geometry();
/*geometry.vertices.push(
	new THREE.Vector3( path[0].position.x, 0, path[0].position.z ),
	new THREE.Vector3( path[1].position.x, 0, path[1].position.z ),
);*/

//convert the path to usable coordinates
makePath(map.path1, map.level1x, map.level1z);

//add the vertices to the path
for(var i=0; i<map.path1.length; i++)
{
	geometry.vertices.push(
	new THREE.Vector3( map.path1[i][0], 0, map.path1[i][1] )
	)
}

//add the line of the path to the scene
//the line is not nescessary for the movement of the cube, but makes the
//path easier to see
var line = new THREE.Line( geometry, material );
scene.add( line );

//array to hold the current dinos in play
var dinos = [];

//add an oviraptor
addOvi(scene, dinos);
addRaptor(scene, dinos);
addTrex(scene, dinos);
console.log("dinos", dinos);

var position = {x: map.path1[0][0], y: 0, z: map.path1[0][1]};

//create a target object with the x and z coordinates from the enemy path
var target = {};
target.x = [];
target.z = [];
target.y = 0;
for(var i=0; i<map.path1.length; i++)
{
	//add the coordinates from the path
	target.x.push(map.path1[i][0]);
	target.z.push(map.path1[i][1]);
}

//create a new tween to move the dinos
console.log("speed", dinos[0][1].speed);
for(var i=0; i<dinos.length; i++)
{
	var moveOvi = new TWEEN.Tween(dinos[i][0].position)
		.to(target, dinos[i][1].speed)
		.start();
	moveOvi.repeat(1000);
}

//array to hold created towers
var towers = [];
		
function tileHover( event ) {

}

/***********************************
addTower function now in pirateT.js
************************************/

//To add towers, use double click

document.addEventListener( 'dblclick', onDocumentMouseDown, false );

function onDocumentMouseDown( event ) {
	event.preventDefault();
	mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

	raycaster.setFromCamera( mouse, camera );
	var intersects = raycaster.intersectObjects( gridT );

	if(intersects[0].object.name == "buildable") {
		scene.remove(intersects[0].object);
		//addpirateT( intersects[0].object.position, scene, gridT, towers );
	}
}

		function onDocumentMouseDown( event ) {
		
			event.preventDefault();
			
			mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

			raycaster.setFromCamera( mouse, camera );
			
			var intersects = raycaster.intersectObjects( gridT );

			console.log(intersects);
			
			if(intersects[0].object.name == "buildable") {
			
				//call viewBuildUI
				
				//build UI shows options for coin 
					//if coin >= tower price, show option
				
				intersects[0].object.name = "tower";
				
				/*******************************************************
				change tower add function to see other types of towers
				*******************************************************/
				
				//calling viewBuildMenu()
				//params - current coins, cost of musket, cost of cannon, cost of net
				//dummy values for now to test disabled buttons
				viewBuildMenu(10, 5, 5, 12);
				decrementGameUIBar("coins", 1);
				
				//addcannonT( intersects[0].object.position, scene, gridT, towers );
			}
			else {
			
				console.log("Can not build", intersects[0].object.name);
			
			}
		}

	}


	init();

	/*Rendering the scene https://www.august.com.au/blog/animating-scenes-with-webgl-three-js/*/

	animate();

	function animate(){
		requestAnimationFrame(animate);
		TWEEN.update();
		renderer.render( scene, camera );
		controls.update();
	}
  
	/*
	
	Resources:
	
	Rendering the scene: 
	https://www.august.com.au/blog/animating-scenes-with-webgl-three-js/
	https://threejs.org/docs/#manual/en/introduction/Creating-a-scene
	
	
	
	*/


</script>
