<script src="/static/three.js"></script>

<script src="/static/OrbitControls.js"></script>
<script src="/static/OBJLoader.js"></script>
<script src="/static/GLTFLoader.js"></script>
<script src="/static/MTLLoader.js"></script>
<script src="/static/WebGL.js"></script>


<script src="/static/stats.min.js"></script>

<link rel="stylesheet" type="text/css" href="/static/css/game-ui.css">

<script src="/static/gameUI.js"></script>
<script src="/static/buildUI.js"></script>
<script src="/static/save.js"></script>
<script src="/static/load.js"></script>


<script src="/static/map1.js"></script>
<script src="/static/pirateT.js"></script>
<script src="/static/cannonT.js"></script>
<script src="/static/ovi.js"></script>
<script src="/static/rap.js"></script>
<script src="/static/trex.js"></script>
<script src="/static/rules.js"></script>

<script type='text/javascript' src='/static/Tween.js'></script>
<script>

	//Music: www.bensound.com Royalty Free Music
	//Sound effects from soundbible.com

	//Global variables
	var scene, camera, renderer, controls, raycaster, mouse, listener;

	//sound variables
	var sound, sound2, dinoSound, played;


	var container, stats, countdown, soundButton;

	//animation variables
	const mixers = [];
	const clock = new THREE.Clock();


	//Game map variables
	var gridT = [];
	var dinos = [];
	var towers = [];
	var projectiles = [];
	//var totWaves, timeXwave;
	//var coins = 100;
	//var curWave = 1;
	//var lives = 3;

	/*We need to RENDER the SCENE with a CAMERA*/
	function init() {

		//for stats
		//https://github.com/mrdoob/three.js/blob/master/examples/webgl_interactive_lines.html
		container = document.createElement('div');
		document.body.appendChild( container );

		var info = document.createElement( 'div' );
		info.style.position = 'absolute';
		info.style.top = '10px';
		info.stylewidth = '100%';
		info.style.textAlign = 'center';
		container.appendChild( info );


		//Create a new scene
		scene = new THREE.Scene();
		console.log("scene", scene);

		//Create a new camera
		//( FOV, aspect ratio, near clipping plane, far clipping plane )
		camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 500 );
		camera.position.set( 0, 10, -10 );
		camera.lookAt( menu );

		//create audio listener
		listener = new THREE.AudioListener();
		camera.add(listener);

		//start audio
		sound = new THREE.Audio(listener);
		var audioLoader = new THREE.AudioLoader();
		audioLoader.load('/static/bensound-instinct.mp3', function(buffer){
			sound.setBuffer(buffer);
			sound.setLoop(true);
			sound.setVolume(2.0);
			sound.play();
		});

		//wave start sound
		dinoSound = new THREE.Audio(listener);
		var dinoAudioLoader = new THREE.AudioLoader();
		dinoAudioLoader.load('/static/TyrannosaurusRex-SoundBible.com-45786848.wav', function(buffer){
			dinoSound.setBuffer(buffer);
			dinoSound.setLoop(false);
			dinoSound.setVolume(8.0);
			dinoSound.setPlaybackRate(1);
		});

		//dino defeated sound
		dinoSound2 = new THREE.Audio(listener);
		var dinoAudioLoader2 = new THREE.AudioLoader();
		dinoAudioLoader2.load('/static/VelociraptorCall-SoundBible.com-1782075819.wav', function(buffer){
			dinoSound2.setBuffer(buffer);
			dinoSound2.setLoop(false);
			dinoSound2.setVolume(6.0);
			dinoSound2.setPlaybackRate(1);
		});

		//Create the renderer
		renderer = new THREE.WebGLRenderer();

		//Set the render size
		renderer.setSize( window.innerWidth, window.innerHeight );

		renderer.setPixelRatio( window.devicePixelRatio );

		//for use with gltf/glb files
		renderer.gammaOutput = true;
		renderer.gammaFactor = 2.2;

		//Add the renderer to the html document
		document.body.appendChild( renderer.domElement );

			//three.js https://github.com/mrdoob/three.js/blob/master/examples/webgl_geometry_text_shapes.html
		window.addEventListener( 'resize', onWindowResize, false );

		/*Adding orbit controls. Allows camera to move*/
		controls = new THREE.OrbitControls( camera, renderer.domElement );

		stats = new Stats();
		//Uncomment for FPS stats
		//container.appendChild( stats.dom );

		controls.target = new THREE.Vector3( 0, 5, 0 );

		controls.enabled = true;
		//This sets the angle to which we can't look "under" the map
		controls.maxPolarAngle = Math.PI / 2;

		console.log("controls",controls);
		console.log("camera",camera);

		//for a static menu
		controls.enableKeys = false;

		//Raycaster
		raycaster = new THREE.Raycaster();
		mouse = new THREE.Vector2();

		//need to add a light so that colors and textures of loaded objects
		//will show up
		var ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
		scene.add(ambientLight);
		animate();
		//Load the menu

		//https://github.com/mrdoob/three.js/blob/master/examples/webgl_geometry_text_shapes.html

		menu();

		//play();

	}

		//https://github.com/mrdoob/three.js/blob/master/examples/webgl_geometry_text_shapes.html

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}



	function render() {


		TWEEN.update();
		controls.update();

		const delta = clock.getDelta();

		mixers.forEach( ( mixer ) => { mixer.update( delta ); } );

		renderer.render( scene, camera );


	}

	function enviroLoader( object, position ) {
		console.log("enviroLoader");
	}

	function towerLoader( object, position, towers ) {
		console.log("towers");
	}

	function dinoLoader( object, position, dinos, delay ) {

		console.log("dinos", dinos);

		//two position variables were creating conflicts
		//dino does not get its position set individually now
		var position = {x: map.path1[0][0], y: 0, z: map.path1[0][1]};

		//create a target object with the x and z coordinates from the enemy path
		var target = {};
		target.x = [];
		target.z = [];
		target.y = 0;
		for(var i=0; i<map.path1.length; i++)
		{
			//add the coordinates from the path
			target.x.push(map.path1[i][0]);
			target.z.push(map.path1[i][1]);
		}

		var targetHealth = {};
		targetHealth.x = [];
		targetHealth.z = [];
		targetHealth.y = 3;
		for(var i=0; i<map.path1.length; i++)
		{
			//add the coordinates from the path
			targetHealth.x.push(map.path1[i][0]);
			targetHealth.z.push(map.path1[i][1]);
		}


		//https://github.com/mrdoob/three.js/blob/master/examples/webgl_animation_multiple.html
		//https://github.com/mrdoob/three.js/blob/master/examples/webgl_animation_keyframes.html
		const loader = new THREE.GLTFLoader();

		const onLoad = ( gltf, position ) => {


			var model = gltf.scene;

			model.position.copy( position );

			var animation = gltf.animations[ 0 ];

			var mixer = new THREE.AnimationMixer( model );
			mixers.push( mixer );

			var action = mixer.clipAction( animation );
			action.play();

			model.scale.set( 0.3, 0.3, 0.3 );

			model.name = "oviraptor";
			model.position.x = map.path1[0][0];
			model.position.z = map.path1[0][1];
			model.userData.health = oviraptor.health;
			model.userData.speed = oviraptor.speed;
			model.userData.reward = oviraptor.reward;
			model.userData.tweenId = oviraptor.tweenId;
			model.type = "Object3D";


			//creating the health bar
			//it has 4 sections that could equal 1/4 of the health of the dino
			var barGemetry = new THREE.BoxGeometry(.25, .25, 1, 1, 1, 4);
			var barMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
			var healthBar = new THREE.Mesh(barGemetry, barMaterial);
			healthBar.position.x = map.path1[0][0];
			healthBar.position.z = map.path1[0][1];

			//make bar float above the dino
			healthBar.position.y = 3;

			//create a new group out of a THREE.Object3D
			//this allows the dino and bar to be moved together
			//the dino and health bar position are not set individually
			//but the group's position is set instead
			dinogroup = new THREE.Group();
			dinogroup.add(model);
			dinogroup.add(healthBar);
			console.log("start pos", map.path1[0][0]);

			console.log("loadDino model:", model);
			console.log("loadDino healthbar:", healthBar);
			console.log("dinogroup", dinogroup );
			//model.add(dino);
			scene.add( dinogroup );

			dinos.push([model,oviraptor]);
			console.log("group ", dinogroup);
			console.log("group pos ", dinogroup.position);
			dinoPath( dinogroup, oviraptor.speed, target, targetHealth, delay );

		};

		const onProgress = () => {};

		const onError = (errorMessage ) => {

			console.log( errorMessage );

		};

		loader.load( object, gltf => onLoad( gltf, position ), onProgress, onError );

	}

	//Creating the opening view of the game's menu
	// function menu() {
	//
	// 	stopAnimation = false;
	//
	// 	var canvas = document.createElement('canvas');
	// 	canvas.id = "canvas1";
	// 	canvas.width = 256;
	// 	canvas.height = 256;
	// 	var context = canvas.getContext('2d');
	// 	context.fillStyle = '#ff0000';
	// 	context.textAlign = 'center';
	// 	context.font = '24px Arial';
	// 	context.fillText("Start Game", 175, 175);
	// 	var amap = new THREE.Texture(canvas);
	// 	amap.needsUpdate = true;
	//
	// 	var mat = new THREE.SpriteMaterial({
	// 		map: amap,
	// 		transparent: false,
	// 		color: 0xffffff
	// 	});
	//
	// 	var sp = new THREE.Sprite(mat);
	// 	sp.scale.set(10, 10, 1);
	// 	sp.name = "playme";
	// 	sp.position.y = 11;
	// 	sp.position.x = 2;
	// 	scene.add(sp);
	// 	gridT.push(sp);
	// 	console.log("sprite", sp);
	//
	// 	var canvas2 = document.createElement('canvas');
	// 	canvas2.width = 600;
	// 	canvas2.height = 256;
	// 	var context2 = canvas2.getContext('2d');
	// 	context2.fillStyle = '#ff0000';
	// 	context2.textAlign = 'center';
	// 	context2.font = '16px Arial';
	// 	context2.fillText("Team Nunki: Christopher Frenchi, Jonathan Ruby, Ruben Torres", 300, 175);
	// 	var amap2 = new THREE.Texture(canvas2);
	// 	amap2.needsUpdate = true;
	//
	// 	var mat2 = new THREE.SpriteMaterial({
	// 		map: amap2,
	// 		transparent: false,
	// 		color: 0xffffff
	// 	});
	//
	// 	var credits = new THREE.Sprite(mat2);
	// 	credits.scale.set(10,10,1);
	// 	credits.name = "credits";
	// 	credits.position.y = 4;
	// 	credits.position.x = 0;
	// 	scene.add(credits);
	// 	gridT.push(credits);
	//
	// 	//disables users ability to move around menu
	// 	controls.enabled = false;
	//
	// 	/*Adding a play button*/
	//
	// 		//Creating a plane
	// 	var buttonGeoPlay = new THREE.PlaneBufferGeometry( 5, 3 );
	// 	console.log( "buttonGeoPlay", buttonGeoPlay );
	// 	buttonGeoPlay.rotateX( 2.677945044588987 );
	// 	buttonGeoPlay.rotateY( -1 );
	// 	buttonGeoPlay.rotateZ( Math.PI );
	//
	// 		//Creating material
	// 	var buttonMatPlay = new THREE.MeshBasicMaterial( { color: 0xffffff } );
	//
	// 		//Creating a mesh
	// 	var playButton = new THREE.Mesh( buttonGeoPlay, buttonMatPlay );
	//
	// 		//Setting variables
	// 	playButton.position.y = 6;
	// 	playButton.rotation.y = -1;
	// 	playButton.name = "play";
	//
	// 		//Pushing to the tile array
	// 	//gridT.push( playButton );
	//
	// 	/*Adding a Credits button*/
	//
	// 		//Creating a plane
	// 	var buttonGeoCredits = new THREE.PlaneBufferGeometry( 3, 1 );
	// 	console.log( "buttonGeoCredits", buttonGeoCredits );
	// 	buttonGeoCredits.rotateX( 2.677945044588987 );
	// 	buttonGeoCredits.rotateY( -1 );
	// 	buttonGeoCredits.rotateZ( Math.PI );
	//
	// 		//Creating material
	// 	var buttonMatCredits = new THREE.MeshBasicMaterial( { color: 0xff00ff } );
	//
	// 		//Creating a mesh
	// 	var creditsButton = new THREE.Mesh( buttonGeoCredits, buttonMatCredits );
	//
	// 		//Setting variables
	// 	creditsButton.position.y = 2;
	// 	creditsButton.rotation.y = -1;
	// 	creditsButton.name = "credits";
	//
	// 		//Pushing to the tile array
	// 	//gridT.push( creditsButton );
	//
	// 	//Add buttons to the scene
	// 	//scene.add( playButton );
	// 	//scene.add( creditsButton );
	//
	// 	//Remove right click menu and add object clicking
	// 	document.addEventListener( 'contextmenu', function( event ) { event.preventDefault() }, false );
	// 	document.addEventListener( 'click', menuSelect, false );
	//
	// 	var menuScope = this;
	//
	// 	function menuSelect( event ) {
	//
	// 		console.log( "mouse: ", event );
	//
	// 		if( event.button == 0 ) {
	//
	// 			event.preventDefault();
	// 			event.stopPropagation();
	//
	// 			mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );
	//
	// 			raycaster.setFromCamera( mouse, camera );
	//
	// 			var intersects = raycaster.intersectObjects( gridT );
	//
	// 			console.log( "intersects", intersects);
	//
	// 			if( intersects.length != 0 ) {
	//
	// 				if(intersects[0].object.name == "playme") {
	//
	// 					document.removeEventListener( 'click', menuSelect, false );
	//
	// 					scene.remove(intersects[0].object);
	//
	// 					setTimeout( function() {
	//
	// 						gridT.pop();
	// 						gridT.pop();
	//
	// 						scene.remove( playButton );
	// 						scene.remove( creditsButton );
	// 						scene.remove(sp);
	// 						scene.remove(credits);
	//
	// 						buttonGeoPlay.dispose();
	// 						buttonGeoCredits.dispose();
	// 						mat.dispose();
	// 						mat2.dispose();
	//
	// 						buttonMatPlay.dispose();
	// 						buttonMatCredits.dispose();
	//
	// 						//google chrome needs a user input to start audio
	// 						sound.context.resume();
	//
	// 					}, 500 );
	//
	// 					//Play the game
	// 					setTimeout( function() { play(); }, 600 );
	//
	// 				} else if ( intersects[0].object.name == "credits" ) {
	//
	// 				}
	//
	//
	// 			}
	//
	// 		}
	//
	// 	}
	//
	// 	console.log("menu");
	//
	// }

	function menu() {
		//disables users ability to move around menu
		controls.enabled = false;

		console.log("menuscene", scene);
		stopAnimation = false;


		/*Adding a play button*/

			//Creating a plane
		var buttonGeoPlay = new THREE.PlaneBufferGeometry( 5, 3 );
		console.log( "buttonGeoPlay", buttonGeoPlay );
		buttonGeoPlay.rotateX( 2.677945044588987 );
		buttonGeoPlay.rotateY( -1 );
		buttonGeoPlay.rotateZ( Math.PI );
			//Creating material
		var buttonMatPlay = new THREE.MeshBasicMaterial( { color: 0xffffff } );

			//Creating a mesh
		var playButton = new THREE.Mesh( buttonGeoPlay, buttonMatPlay );

			//Setting variables
		playButton.position.y = 6;
		playButton.rotation.y = -1;
		playButton.name = "play";

			//Pushing to the tile array
		gridT.push( playButton );



		/*Adding a Credits button*/

			//Creating a plane
		var buttonGeoCredits = new THREE.PlaneBufferGeometry( 3, 1 );
		console.log( "buttonGeoCredits", buttonGeoCredits );
		buttonGeoCredits.rotateX( 2.677945044588987 );
		buttonGeoCredits.rotateY( -1 );
		buttonGeoCredits.rotateZ( Math.PI );
			//Creating material
		var buttonMatCredits = new THREE.MeshBasicMaterial( { color: 0xff00ff } );

			//Creating a mesh
		var creditsButton = new THREE.Mesh( buttonGeoCredits, buttonMatCredits );

			//Setting variables
		creditsButton.position.y = 2;
		creditsButton.rotation.y = -1;
		creditsButton.name = "credits";

			//Pushing to the tile array
		gridT.push( creditsButton );
		//Add buttons to the scene
		scene.add( playButton );
		scene.add( creditsButton );


		//Remove right click menu and add object clicking
		document.addEventListener( 'contextmenu', function( event ) { event.preventDefault() }, false );
		document.addEventListener( 'click', menuSelect, false );

		var menuScope = this;

		function menuSelect( event ) {

			console.log( "mouse: ", event );

			if( event.button == 0 ) {

				event.preventDefault();
				event.stopPropagation();

				mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );
				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( gridT );
				console.log( "intersects", intersects);

				if( intersects.length != 0 ) {

					if(intersects[0].object.name == "play") {

						document.removeEventListener( 'click', menuSelect, false );

						scene.remove(intersects[0].object);

						setTimeout( function() {

							gridT.pop();
							gridT.pop();

							scene.remove( playButton );
							scene.remove( creditsButton );

							buttonGeoPlay.dispose();
							buttonGeoCredits.dispose();

							buttonMatPlay.dispose();
							buttonMatCredits.dispose();

						}, 500 );
						//Play the game
						setTimeout( function() { play(); }, 600 );

					} else if ( intersects[0].object.name == "credits" ) {

						//Show credit screen



					}

				}

			}

		}
		console.log("menu");
	}

	function getCoins(){
		console.log("Current Coins var", coins);
		return coins;
	}
	function setCoins( newValue ){
		console.log("coins", coins);
		coins = newValue;
	}
	function getLives(){
		console.log("Current Lives var", lives);
		return lives;
	}
	function setLives( newValue ){
		console.log("lives", lives);
		lives = newValue;
	}
	function getWave(){
		console.log("Current Wave", curWave);
		return curWave;
	}
	function setWave( newValue ){
		console.log("wave:", curWave);
		curWave = newValue;
	}

	//Creating the game engine and functionality
	function play() {
		initBuildUI();
		viewBuildMenu();
		setLives(1);
		setWave(1);
		if(stopAnimation){
			console.log("sa******************************",stopAnimation);
			return;
		}
		// if(document.getElementById("buildUIcontainer") == false ){
		//
		//
		// }
		//load.js
		//loadGame();
		/*

		Game variables to be set by map file:

		Total Waves = totWaves
		Current Wave = curWave
		Time between Waves = timeXwave
		Player lives = lives

		Player coins = coins



		var towerClock = new THREE.Clock();

		clock.startTime;

		*/

		//create a button to pause the audio
		soundButton = document.createElement('button');
		soundButton.style.position = 'absolute';
		soundButton.id = 'soundButton';
		soundButton.style.width = '100px';
		soundButton.style.height = '50px';
		soundButton.style.background = 'green';
		soundButton.style.top = '0px';
		soundButton.style.left = '375px';
		soundButton.style.textAlign = 'center';
		soundButton.innerHTML = 'Music';
		soundButton.style.color = 'white';

		document.body.appendChild(soundButton);
		soundButton.onclick = function(){
			if(sound.isPlaying){
				sound.pause();
				soundButton.style.background = 'red';
			}
			else{
				soundButton.style.background = 'green';
				sound.play();
			}
		};

		//add a countdown timer
		countdown = document.createElement('div');
		countdown.style.position = 'absolute';
		countdown.id = 'countdown';
		countdown.style.width = "200px";
		countdown.style.height = '50px';
		countdown.style.background = 'green';
		countdown.style.top = '50px';
		countdown.style.left = '50%';
		countdown.style.textAlign = 'center';
		document.body.appendChild(countdown);

		played = 1;
		var timeleft = 10;
		if( document.getElementById("countdown") == true){
			var countdownTimer = setInterval(function(){
				document.getElementById("countdown").innerHTML = timeleft + " seconds remaining";
				timeleft -= 1;
				if(timeleft == -1){
					document.getElementById("countdown").innerHTML = "Start"
					if(played == 1)
					{
						dinoSound.play();
					}
				}
				else if(timeleft < -1){
					clearInterval(countdownTimer);
					document.getElementById("countdown").style.display = "none";
				}
			}, 10000);
		}




		initGameUI(coins, lives, curWave);

		//allows user to move the map
		controls.enabled = true;

		/*Adding a plane to the scene*/
		var planeGeo = new THREE.PlaneBufferGeometry( 4, 4 );
		planeGeo.rotateX( - Math.PI / 2 );

		//Testing maps0.js
		//var jsMap = maps;

		//console.log(".js MAP: ",jsMap.mapArray[0].name, jsMap.mapArray[0].map);


		//Added a map as an arraytimeleft
		// var map0 = ['a', 'b', 'a', 'b'];
		// var map1 = ['b', 'a', 'b', 'a'];
		// var map2 = ['a', 'b', 'a', 'b'];
		// var map3 = ['b', 'a', 'b', 'a'];
		// var map4 = ['a', 'b', 'a', 'b'];
		// var m = [map0, map1, map2, map3, map4];





		var gridTiles = [];

		//var gridTiles = [];timeleft
		var path = [];
		function addTiles(m){
			console.log("adding tiles", m);
			//gets the length of a single array (map0 a,b,a,b)
			var arrZ = m[0].length;
			//get the number of arrays (map0, map1, map2, map3)
			var arrX = m.length;
			console.log("arr", arrX, arrZ);

			//
			for( var i = 0, x = -(arrX/2); x < (arrX/2); x++, i++ ){
				var gridRow = [];
				for( var j = 0, z= -(arrZ/2); z < (arrZ)/2; z++, j++ ){
					console.log("\n",x,z, m[i][j], i, j);

					//Creating new variable plane every instance and adding to
					//the scene. Position offset by 4 because it seems to be the
					//internal size of that object
					if(m[i][j] == '.'){
						var plane = new THREE.Mesh( planeGeo, new THREE.MeshBasicMaterial( { color: 0x416600 } ) );
						plane.position.x = 4*x+2;
						plane.position.z = 4*z+2;
						//name need for raycaster build logic
						plane.name = "buildable";
						gridRow.push( plane );
						//for testing raycaster
						gridT.push( plane );
						scene.add( plane );
					}
					else if (m[i][j] == '*'){
						var plane = new THREE.Mesh( planeGeo, new THREE.MeshBasicMaterial( { color: 0xf2d527 } ) );
						plane.position.x = 4*x+2;
						plane.position.z = 4*z+2;
						gridRow.push( plane );
						path.push(plane);
						//for testing raycaster
						gridT.push( plane );
						scene.add( plane );
					}
					else if (m[i][j] == 's'){
						var plane = new THREE.Mesh( planeGeo, new THREE.MeshBasicMaterial( { color: 0x4568c2 } ) );
						plane.position.x = 4*x+2;
						plane.position.z = 4*z+2;
						plane.name = "start";
						gridRow.push( plane );
						console.log("start ", plane);
						//for testing raycaster
						gridT.push( plane );
						scene.add( plane );
					}
					else if (m[i][j] == 'e'){
						var plane = new THREE.Mesh( planeGeo, new THREE.MeshBasicMaterial( { color: 0xa12b0d } ) );
						plane.position.x = 4*x+2;
						plane.position.z = 4*z+2;
						plane.name = "end";
						gridRow.push( plane );
						console.log("end", plane);
						//for testing raycaster
						gridT.push( plane );
						scene.add( plane );
					}
				}
				gridTiles.push( gridRow );
				console.log("gridRow", gridRow );
			}
		}
				//addTiles(m);
		addTiles(map.level1);
		console.log("path ", path);

		//create a line to show the path
		var material = new THREE.LineBasicMaterial({
			color: 0x0000ff
		});


		var geometry = new THREE.Geometry();

		//convert the path to usable coordinates
		console.log("Before make path", map.path1, map.level1x, map.level1z);
		var testpath = [];
		testpath = map.path1;
		console.log("map.path1", map.path1);
		console.log("testpath", testpath);
		var newArrtest = testpath.slice();
		console.log("newArrtest", newArrtest);

		//makePath(newArrtest, map.level1x, map.level1z);

		//add the vertices to the path
		for(var i=0; i<map.path1.length; i++)
		{
			geometry.vertices.push(
			new THREE.Vector3( map.path1[i][0], 0, map.path1[i][1] )
			)
		}

		//add the line of the path to the scene
		//the line is not nescessary for the movement of the cube, but makes the
		//path easier to see
		var line = new THREE.Line( geometry, material );
		scene.add( line );


		setTimeout(function(){
			curWave = 1;
			mapWaves(curWave);
		}, 10000);


		console.log("dinos array", dinos );


		function tileHover( event ) {

		}

		/***********************************
		addTower function now in pirateT.js
		************************************/

		//To add towers, use double click

		document.addEventListener( 'dblclick', onDocumentMouseDown, false );

		function onDocumentMouseDown( event ) {
			event.preventDefault();
			mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

			raycaster.setFromCamera( mouse, camera );
			var intersects = raycaster.intersectObjects( gridT );

			if(intersects[0].object.name == "buildable") {
				scene.remove(intersects[0].object);
				//addpirateT( intersects[0].object.position, scene, gridT, towers );
			}
		}

		function onDocumentMouseDown( event ) {

			event.preventDefault();

			mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

			raycaster.setFromCamera( mouse, camera );

			var intersects = raycaster.intersectObjects( gridT );

			console.log(intersects);

			if(intersects[0].object.name == "buildable") {


				var possibleCoins = 0;

				//shows build options for player's current coin at this location (need to change first param to coin
				//last param to cost of last tower

				viewBuildMenu(getCoins(), pirateT.cost, cannonT.cost, cannonT.cost);

				//remove the previous click event (which was to build for last location)
				document.getElementById("build-musket-button").removeEventListener("click", clickMusket);
				document.getElementById("build-cannon-button").removeEventListener("click", clickCannon);
				document.getElementById("build-net-button").removeEventListener("click", clickNet);

				//create building sound
				sound2 = new THREE.Audio(listener);
				var audioLoader2 = new THREE.AudioLoader();
				audioLoader2.load('/static/Hammer.wav', function(buffer){
					sound2.setBuffer(buffer);
					sound2.setLoop(false);
					sound2.setVolume(8.0);
					sound2.setPlaybackRate(1);
				});

				//new build functions at this location
				clickMusket = function () {
						console.log("Clicked Musket Tower")
  						clearBuildMenu();
						coins = coins - pirateT.cost;
						updateGameUIbar("coins", coins);
						intersects[0].object.name = "tower";
						addpirateT( intersects[0].object.position, scene, gridT, towers );
						//start audio
						sound2.play();
						};

				clickCannon = function() {
						console.log("Clicked Cannon Tower")
  						clearBuildMenu();
						coins = coins - cannonT.cost;
						updateGameUIbar("coins", coins);
						//getCoins();
						intersects[0].object.name = "tower";
						addcannonT( intersects[0].object.position, scene, gridT, towers );
						console.log("towers", towers);
						//start audio
						sound2.play();
						};

				clickNet = function() {
						console.log("Clicked Net Tower")
  						clearBuildMenu();
						coins = coins - pirateT.cost;
						updateGameUIbar("coins", coins);
						intersects[0].object.name = "tower";
						addcannonT( intersects[0].object.position, scene, gridT, towers );
						sound2.play();
						};


				//new events for on click at this location
				document.getElementById("build-musket-button").addEventListener("click", clickMusket);
				document.getElementById("build-cannon-button").addEventListener("click", clickCannon);
				document.getElementById("build-net-button").addEventListener("click", clickNet);

			}
			else {

				console.log("Can not build", intersects[0].object.name);

			}
		}

	}

	// var points = [];
	// for(var i=0; i<map.path1.length; i++)
	// {
	// 	points.push(new THREE.Vector3(map.path1[i][0], 0, map.path1[i][1]));
	// }
	//
	// spline = new THREE.CatmullRomCurve3(points);



	// function that sends a dino down the path
	// target is the path determined by the map
	// delay is determined by the wave
	// uses onUpdate to change the rotation of the dino in relation to the y axis
	function dinoPath(dino, speed, target, targetHealth, delay) {

		console.log("dino in dinoPath", dino);
		console.log(dino.children);
		console.log(dino.children.length);
		//dino.children because we are passing in a group
		for( var dc = 0; dc < dino.children.length; dc++){

			dino.children[dc].rotation.y = 300;

			var move = new TWEEN.Tween(dino.children[0].position)
				.to(target, speed).delay(delay)
				.onUpdate(function(){
					dino.children[0].userData.tweenId = move.getId();
					//console.log("dino tweenid", move.getId());
					//to the left, good
					if(dino.children[0].position.z == -6 && dino.children[0].position.x > -18 && dino.children[0].position.x < -6){
						dino.children[0].rotation.y = 0;
					}

					//down, good
					else if(dino.children[0].position.x == -6 && dino.children[0].position.z < -6 && dino.children[0].position.z > -10){
						dino.children[0].rotation.y = 89.5;
					}

					//to the left, good
					else if(dino.children[0].position.z == -10 && dino.children[0].position.x > -5 && dino.children[0].position.x < 2){
						dino.children[0].rotation.y = 0;
					}

					//up, good
					else if(dino.children[0].position.x == 2 && dino.children[0].position.z > -10 && dino.children[0].position.z < -6){
						dino.children[0].rotation.y = 300;
					}

					//left, good
					else if(dino.children[0].position.z == -6 && dino.children[0].position.x > 2 && dino.children[0].position.x < 6){
						dino.children[0].rotation.y = 0;
					}

					//up, good
					else if(dino.children[0].position.x == 6 && dino.children[0].position.z > -5 && dino.children[0].position.z < 10){
						dino.children[0].rotation.y = 300;
					}

					//left, good
					else if(dino.children[0].position.z == 10 && dino.children[0].position.x > 2 && dino.children[0].position.x < 10){
						dino.children[0].rotation.y = 0;
					}

					//down, good
					else if(dino.children[0].position.x == 10 && dino.children[0].position.z < 10 && dino.children[0].position.z > 2){
						dino.children[0].rotation.y = 89.5;
					}

					//left, good
					else if(dino.children[0].position.z == 2 && dino.children[0].position.x > 10 && dino.children[0].position.x < 18){
						dino.children[0].rotation.y = 0;
					}

					//up, disappears
					else if(dino.children[0].position.x == 18 && dino.children[0].position.z > 2 && dino.children[0].position.z < 18){
						dino.children[0].rotation.y = 300;
					}
					//console.log("dino pos ", dino.position);

				})
				.start();
				//removes the dino from the scene once it has reached the end

					//health bar

			var healthmove = new TWEEN.Tween(dino.children[1].position)
				.to(targetHealth, speed).delay(delay)
				.onUpdate(function(){
					if(dino.children[1].position.z == -6 && dino.children[1].position.x > -18 && dino.children[1].position.x < -6){
						dino.children[1].rotation.y = 0;
					}

					//down, good
					else if(dino.children[1].position.x == -6 && dino.children[1].position.z < -6 && dino.children[1].position.z > -10){
						dino.children[1].rotation.y = 89.5;
					}

					//to the left, good
					else if(dino.children[1].position.z == -10 && dino.children[1].position.x > -5 && dino.children[1].position.x < 2){
						dino.children[1].rotation.y = 0;
					}

					//up, good
					else if(dino.children[1].position.x == 2 && dino.children[1].position.z > -10 && dino.children[1].position.z < -6){
						dino.children[1].rotation.y = 300;
					}

					//left, good
					else if(dino.children[1].position.z == -6 && dino.children[1].position.x > 2 && dino.children[1].position.x < 6){
						dino.children[1].rotation.y = 0;
					}

					//up, good
					else if(dino.children[1].position.x == 6 && dino.children[1].position.z > -5 && dino.children[1].position.z < 10){
						dino.children[1].rotation.y = 300;
					}

					//left, good
					else if(dino.children[1].position.z == 10 && dino.children[1].position.x > 2 && dino.children[1].position.x < 10){
						dino.children[1].rotation.y = 0;
					}

					//down, good
					else if(dino.children[1].position.x == 10 && dino.children[1].position.z < 10 && dino.children[1].position.z > 2){
						dino.children[1].rotation.y = 89.5;
					}

					//left, good
					else if(dino.children[1].position.z == 2 && dino.children[1].position.x > 10 && dino.children[1].position.x < 18){
						dino.children[1].rotation.y = 0;
					}

					//up, disappears
					else if(dino.children[1].position.x == 18 && dino.children[1].position.z > 2 && dino.children[1].position.z < 18){
						dino.children[1].rotation.y = 300;
					}

					//reduce healthbar
					if(dino.children[0].userData.health < oviraptor.health * .66 && dino.children[0].userData.health > oviraptor.health * .33)
					{
						dino.children[1].scale.z = .66;
					}
					else if(dino.children[0].userData.health < oviraptor.health * .33)
					{
						dino.children[1].scale.z = .33;
					}

					// if(getLives() <= 0 ){
					// 	Tween.remove(healthmove.getId());
					// }
				})
				.start();
			//removes the dino from the scene once it has reached the end
			healthmove.onComplete(function(){
					console.log("end of path", dino);
					console.log("dinos...", dinos);
					var endDinolength = dinos.length;
					curLives = getLives();
					//two children being removed.
					var dinoEnder = dino.parent;
					for(var dinosleft = 0; dinosleft < dinos.length; dinosleft++){
						console.log("for", dinos[dinosleft]);
						console.log("DINO UUID", dino.children[0].uuid, dinos[dinosleft][0].uuid);
						if(dino.children[0].uuid == dinos[dinosleft][0].uuid){
							console.log("HERERERERER", dino.uuid, dinos[dinosleft][0].uuid);
							curLives -= .5;
							setLives(curLives);
							updateGameUIbar( "lives", getLives() );
							scene.remove(dino);

						}

					};

					if( getLives() <= 0 ){

						//TWEEN.removeAll();
						//healthmove.removeAll();

						loseCondition();
					}
			});
		//
		}

	}


	init();

	/*Rendering the scene https://www.august.com.au/blog/animating-scenes-with-webgl-three-js/*/
	//animate();

	var stopAnimation = false;

	function animate(){

		if(stopAnimation){
			console.log("stopped");
		}
		else{



			//https://stackoverflow.com/questions/14465495/how-do-i-stop-requestanimationframe
			if( towers.length >= 1 ){
				for( var i = 0; i < towers.length; i++ ) {
		    	//console.log("for i", i );
		      var tc = towers[i].children;
		      for( var j = 0; j < tc.length; j=j+2) {
						attack( coins, towers, dinos );
		      };
				};

			}
			if( projectiles.length > 0 ){
				for( var p = 0; p < projectiles.length; p++){

					projectiles[p].position.y -= .2;

					if ( projectiles[p].position.x > projectiles[p].userData.x ){
						projectiles[p].position.x -= .75;
					}
					if ( projectiles[p].position.z > projectiles[p].userData.z ){
						projectiles[p].position.z -= .75;

					}
					if ( projectiles[p].position.x < projectiles[p].userData.x){
						projectiles[p].position.x += .75;

					}
					if ( projectiles[p].position.z < projectiles[p].userData.z){
						projectiles[p].position.z += .75;

					}

					projectiles[p].position.y -= .2;

					if (projectiles[p].position.y <= 0){

						scene.remove(projectiles[p]);
						projectiles.splice(p, 1);

					}
				}

			}

			requestAnimationFrame(animate);
			TWEEN.update();
			const delta = clock.getDelta();
			mixers.forEach( ( mixer ) => {
				mixer.update( delta );
			});
			renderer.render( scene, camera );
			controls.update();
			//Uncomment for FPS stats
			//stats.update();
		}
	}

	/*

	Resources:
	https://www.august.com.au/blog/animating-scenes-with-webgl-three-js/
	https://threejs.org/docs/#manual/en/introduction/Creating-a-scene



	*/

</script>
